// Copyright 2022 Eric Fichter
#ifndef CFACE_H
#define CFACE_H

#include "headers.h"

class oFace;

class Layer;

//! Describes a physical or virtual face, potentially representing a space boundary which
//! - has a geometric and topological shape (TopoDS_Face)
//! - has an ancestor from which it was generated by geometric algorithms
//! - has an orientation for the underlying shape, in
//! - has several attributes explaining its topological context within building
//! - has several attributes declaring IFC space boundary attributes
class cFace {
public:
    //! Constructor needing a unique identified.
    cFace(TopoDS_Face _face, oFace *_face_original, unsigned int _id, cFace *_superface = nullptr);

    bool operator==(const cFace &F) const { return id == F.id; }

    //! TopoDS_Face of this. TopoDS_Face references an TShape (geometry). Has its own Location and attributes (e.g. orientation).
    //! TopoDS_Face is not a pointer!
    TopoDS_Face face;

    //! TopoDS_Face: TopoDS_Edge hash to TopoDS_Edge
    std::unordered_map<unsigned int, TopoDS_Shape> halfedges; // TopoDS_Edge id (hash) to TopoDS_Edge

    //! TopoDS_Face: TopoDS_Edge hash to adjacent cFaces.
    std::unordered_map<unsigned int, std::list<cFace *>> adjacentfaces;

    //! Returns angle in radians between two adjacent faces sharing an edge.
    static double angle_between_planar_adjacent_faces(gp_Dir n1, gp_Dir v1, gp_Dir n2, gp_Dir v2, gp_Pnt c);

    //! Returns hash code of underlying TopoDS_Face.
    //! - cFaces can share same TopoDS_Face and therefore hash code.
    //! - Hash is computed from the TShape and the Location of the TopoDS_Face. The Orientation is not used.
    //! So coplanar faces can have same hash, even if they are oppositely oriented.
    unsigned int FaceID() const;

    //! Returns false if normals of face and ancestor face have an angle higher than 90 degree
    //! indicating a flip of orientation.
    bool CheckFaceNormal(bool &normal_was_checked) const;

    //! Complements face if orientation was reversed.
    void CheckSetFaceNormal();

    //! Returns false if normals of face and other face have an angle higher than 90 degree
    //! indicating a flip of orientation.
    bool AngleToFaceSmaller90(const cFace &f) const;

    //! Flip orientation of underlying TopoDS_Face.
    void ComplementFace();

    //! Clears map halfedges and stores TopoDS_Edges of current face.
    void UpdateHalfEdges();

    //! Returns true if halfedges contains edge with theId.
    bool IsIdInHalfEdges(unsigned int theId);

    //! Returns the distance (calculated within ray tracing) to next face behind. Default value is -1.
    double DistanceToSpaceBoundaryBehind() const;

    //! Returns mid point of edge with desired edgeID. Attention: No check is made, if edge with edgeID exists. Test beforehand.
    gp_Pnt MidPoint(unsigned int edgeID);

    //! Returns vector of edge with desired edgeID considering topological orientation. Attention: No check is made, if edge with edgeID exists. Test beforehand.
    gp_Dir EdgeVector(unsigned int edgeID);

    //! Clear halfedges and edgeId2adjacentcFaces.
    void ClearMaps();

    //! Creates a ray object in opposite direction of face normal. Length is determined by material list.
    IntersectionRay RayBehind(double tol);

    //! Creates a ray object in opposite direction of face normal. Length is determined argument l.
    IntersectionRay RayBehind(double tol, double l);

    //! Returns true, if face has only linear edges and face is planar.
    bool IsPolygon() const;

    //! Returns true, if ancestor face is linked to an opening (e.g. window).
    bool IsOpening() const;

    //! Returns true, if ancestor face is an offset face.
    bool IsOffset() const;

    //! Returns true, if face is still adjacent to other faces from same original shell of ifc product.
    bool IsConnectedToShell();

    //! Returns surface area.
    double SurfaceArea() const;

    //! Returns the ifc product face belongs to.
    IfcUtil::IfcBaseEntity *IfcProduct() const;

    //! Returns SB_internal_or_external_boundary attribute.
    SB_internal_or_external_boundary InternalOrExternal() const;

    //! Returns SB_physical_or_virtual_boundary attribute.
    SB_physical_or_virtual_boundary PhysicalOrVirtual() const;

    //! Returns face normal of ancestor face.
    gp_Dir AncestorNormal() const;

    //! Returns face normal.
    gp_Dir FaceNormal() const;

    //! Returns fixed face normal.
    gp_Dir FixedFaceNormal() const;

    //! Returns center of mass.
    gp_Pnt Center() const;

    //! Returns a name based on multiple attributes.
    std::string STLSolidName();

    //! Returns a vector of pairs containing a reference to a product and the thickness of this product behind this.
    std::vector<std::pair<Product *, double>> MaterialLayers(std::set<std::pair<Product *, Product *>> &collisions);

    //! Returns true if face is enclosed within a shape, so that there are two adjacent faces embracing the face.
    bool IsEnclosed(const TopTools_IndexedDataMapOfShapeListOfShape &edgeFaceMap, std::unordered_map<unsigned int, std::list<cFace *>> &id2cFaces, std::list<cFace> &cFaces);

    //! Returns edges from face, that are flagged as internal or external by OCC.
    void RemoveSeamEdgesFromFace();

    //! Updates edgeId2adjacentcFaces map by evaluating edgeFaceMap.
    void UpdateFaceAdjacencies(const TopTools_IndexedDataMapOfShapeListOfShape &edgeFaceMap, std::unordered_map<unsigned int, cFace *> &id2cFace);

    //! Removes adjacent faces from edgeId2adjacentcFaces if half edges have same direction.
    void RemoveWrongOrientedAdjacentFaces();

    //! Removes adjacent faces on each edge until there is only one manifold adjacent face. Criteria: face with smallest angle.
    void RemoveNonManifoldAdjacencyByAngle();

    //! Tries to connect adjacent parallel edges.
    void ReduceEdges();

    //! Returns false if attribute isHanging is true.
    //! If attribute is false, function returns true, if there is at least on edge without an adjacent face (whicht is also not hanging and not an offset face).
    bool SetHanging();

    //! Returns true, if there is more than 1 wire in face, indicating prsence of holes.
    bool HasHoles() const;

    //! Returns true, if no corresponding face or corresponding face matches geometric criteria.
    bool CheckCorresponding(double tol_area, double tol_angle);

    //! Returns true, if no parent face or parent face matches geometric criteria.
    bool CheckParent(double tol_dist, double tol_angle);

    //! Returns false, if space behind and space of corresponding face do not match.
    bool CheckSpaceBehind();

    //! For debugging. Find null pointer.
    void CheckPointers(bool secondlvl);

    //! Removes adjacent faces from adjacentfaces if their attribute isTrash is true.
    void RemoveTrashedAdjacentFaces();

    //! Generates new face from adjacent and parallel faces.
    void UnifyFaces(std::set<cFace *> &faces_to_unify);

    //! Returns true if face contains internal or external edge.
    bool FaceContainsSeamEdges() const;

    //! Returns attribute isTrash.
    bool IsTrash() const;

    //! Returns attribute IsInner.
    bool IsInner() const;

    //! Returns attribute IsHanging.
    bool IsHanging() const;

    //! Returns attribute isCoplanar.
    bool IsCoplanar() const;

    //! Returns if face's is linked to an IfcVirtualElement.
    bool IsVirtual() const;

    //! Returns attribute wasVisited.
    bool WasVisited() const;

    //! Returns whether outer wire of face is convex.
    bool IsConvex() const;

    //! Returns whether face could be a shading face according to some criteria.
    bool IsPotentiallyShading(const std::set<Product *> &products_bounding_ifcspaces) const;

    //! Returns main direction (0 = X, 1 = Y or 2 = Z) of surface normal.
    long ProjectionAxis() const;

    //! Returns the outer wire.
    TopoDS_Wire OuterWire() const;

    //! Returns vector of projected points (projection according to ProjectionAxis()).
    std::vector<gp_Pnt2d> ProjectOuterWireTo2D() const;

    //! Returns attribute id.
    unsigned int ID() const;

    //! Returns a COPY of the list of faces, that were created by splitting this face.
    std::list<cFace *> Subfaces() const;

    //! Returns a COPY of the materials map.
    std::map<Product *, std::set<double>> Materials() const;

    //! Returns space the face belongs to.
    Space *RelSpace() const;

    //! Returns space boundary type of the face.
    SB_Type SBType() const;

    //! Returns ancestor face.
    oFace *Ancestor() const;

    //! Returns space behind the face.
    Space *SpaceBehind() const;

    //! Returns related product.
    Product *RelProduct() const;

    //! Returns parent face according to ifc definition.
    cFace *Parent() const;

    //! Returns superface, e.g. a 1st lvl face for an 2nd level face.
    cFace *Superface() const;

    //! Returns face that was kept after face union, where this was involved.
    cFace *UnifyingFace() const;

    //! Returns corresponding face according to ifc definition.
    cFace *Corresponding() const;

    //! Returns attribute P (point on face).
    gp_Pnt PointOnFace() const;

    //! Recursively creates set of adjacent faces (starting with this) that meet attribute criteria.
    //! Will not add opening faces if this is not an opening.
    std::set<cFace *> UnifyableFacesMaintainHoles();

    //! Recursively creates set of adjacent faces (starting with this) that meet attribute criteria.
    //! Will also add opening faces if this is not an opening.
    std::set<cFace *> UnifyableFacesOvertakeOpenings();

    //! Get adjacent faces. Only works for first level faces.
    std::set<cFace *> AdjacentFacesList() const;

    //! Recursively creates set of adjacent opening faces (starting with this).
    std::set<cFace *> UnifyableFacesOpeningsOnly();

    //! Returns related ifc entity of class IfcRelSpaceBoundary. If non-existent returns nullptr.
    IfcUtil::IfcBaseEntity *IfcRelSpaceBoundary() const;

    //! Returns a COPY of the TopoDS_Face. Changes on this face will have no effect on this.
    TopoDS_Face Face() const;

    //! Returns name of the IfcClass.
    std::string IfcClass() const;

    //! Returns guid of the relating product.
    std::string IfcGuid() const;

    //! Returns true if product is of specified IfcClass.
    bool IsIfcClass(std::string s) const;

    //! Sets the space.
    void SetSpace(Space *s);

    //! Sets the space behind.
    void SetSpaceBehind(Space *s);

    //! Sets materials.
    void SetMaterials(const std::map<Product *, std::set<double>> &M);

    //! Clear materials.
    void ClearMaterials();

    //! Sets attribute internalOrExternal.
    void SetInternalOrExternal(SB_internal_or_external_boundary e);

    //! Sets attribute physicalOrVirtual.
    void SetPhysicalOrVirtual(SB_physical_or_virtual_boundary e);

    //! Sets id.
    void SetID(unsigned int n);

    //! Sets space boundary type.
    void SetSBType(SB_Type t);

    //! Sets attribute isTrash.
    void SetIsTrash(bool b);

    //! Sets attribute parent.
    void SetParent(cFace *p);

    //! Sets attribute isCoplanar.
    void SetIsCoplanar(bool b);

    //! Sets related space boundary.
    void SetIfcRelSpaceBoundary(IfcUtil::IfcBaseEntity *sb);

    //! Sets attribute isInner.
    void SetIsInner(bool b);

    //! Sets attribute wasVisited.
    void SetWasVisited(bool b);

    //! Sets ancestor faced.
    void SetAncestor(oFace *o);

    //! Sets corresponding face.
    void SetCorresponding(cFace *corr);

    //! Sets unifying face.
    void SetUnifyingFace(cFace *f);

    //! Sets super face.
    void SetSuperface(cFace *f);

    //! Sets P.
    void SetPointOnFace(gp_Pnt Q);

    //! Adds face to the subface list.
    void AppendToSubfaces(cFace *f);

    //! Removes face from the subface list.
    void RemoveFromSubfaces(cFace *f);

    //! Removes face from the subface list of its superface.
    void RemoveFromSubfacesOfSuperFace();

    //! Adds element to materials.
    void AppendToMaterial(Product *p, double d);

    //! Attributes face as an virtual space boundary.
    void SetPropertiesVirtualElement();

    //! Sets fixed face normal.
    void SetFixedFaceNormal(gp_Dir v);

    //! Sets IFC attributes of the face.
    void SetPropertiesSpaceBoundary(cFace *behind_cface, bool behind_face_is_corresponding, double min_dist, double bounds_min_Z, gp_Pnt C);

    //! Print attributes.
    void Log(unsigned int i) const;

    //! String with basic info.
    std::string Info() const;

    //! Applies AppendToSubfaces and SetSuperface.
    static void AddSuperfaceSubfaceRelationship(cFace *superface, cFace *subface);

    //! Returns attribute status_normal.
    face_normal_status NormalStatus() const;

    //! Sets attribute status_normal and if status is "known" also sets fixed_normal.
    void SetNormalStatus(face_normal_status s);

    //! Sets IFC attributes of the face.
    void SetPropertiesSpaceApproach(cFace *behind_cface, bool behind_face_is_corresponding, double min_dist, double bounds_min_Z, gp_Pnt C);

    //! Creates a ray object in opposite direction of face normal. Length is determined argument l.
    IntersectionRay RayBehindSpaceApproach(double tol, double transmission_length);

    //! Get neighbor face of list L with smallest angle and its desired orientation to have that angle.
    oriFace *FaceWithMinimalAngleConsiderBothOrientations(unsigned int edge_id, used_orientation o1, std::list<oriFace> &L);

private:
    oFace *ancestor;
    unsigned int id;
    bool isTrash;
    bool isHanging;
    bool wasVisited;
    bool isInner;
    bool isCoplanar;
    enum SB_Type sb_type;
    enum SB_internal_or_external_boundary internalOrExternal;
    enum SB_physical_or_virtual_boundary physicalOrVirtual;
    Space *space;
    Space *space_behind;
    cFace *unifying_face;           // face that unified this face
    cFace *parent;                  // coplanar face enclosing this face (opening in wall)
    cFace *corresponding;           // coplanar face at "other" end of heat flux
    cFace *superface;               // inverse of subfaces
    std::list<cFace *> subfaces;    // faces generated by splitting this face
    IfcUtil::IfcBaseEntity *ifcrelspaceboundary; // ifcrelspaceboundary instance
    std::map<Product *, std::set<double>> materials; // material behind the face. Stored as references to products and the distance from face to product faces
    gp_Pnt P; // point on face, if possible in face center
    gp_Dir fixed_normal; // desired face normal
    face_normal_status status_normal; // if desired normal is same as actual normal
    double distance; // distance to next space boundary defined in ray tracing

    static gp_Dir vector_on_plane(gp_Dir n, gp_Dir v);

    static double degree_angle_from_unit_arc_edge(const TopoDS_Edge &Edge);

    static gp_Pnt point_on_plane(gp_Dir r, gp_Pnt c);

    bool is_enclosed_offset(const TopTools_IndexedDataMapOfShapeListOfShape &edgeFaceMap, std::unordered_map<unsigned int, std::list<cFace *>> &id2cFaces, std::list<cFace> &cFaces);

    bool is_enclosed_shell(const TopTools_IndexedDataMapOfShapeListOfShape &edgeFaceMap, std::unordered_map<unsigned int, std::list<cFace *>> &id2cFaces, std::list<cFace> &cFaces);

    bool is_face_on_wrong_side(cFace *other_cface) const;

    bool is_enclosed_by_pair_faces(cFace *second0, cFace *second1, unsigned int edge_id);

    static std::unordered_map<std::basic_string<char>, std::vector<cFace *>> find_pairs_by_guid(const std::list<cFace *> &adjacent_cfaces);

    bool is_edge_id_in_maps(unsigned int ID);

    template<typename Map>
    bool map_compare_keys(Map const &lhs, Map const &rhs);

    template<typename Map>
    bool map_compare(Map const &lhs, Map const &rhs);

    static cFace *face_with_minimal_angle_correct_oriented_edge(unsigned int edge_id, gp_Dir n1, gp_Dir v1, gp_Pnt c, const std::set<cFace *> &L);

    std::list<Layer> get_layers();

    static std::list<Layer> get_splitlayers(std::list<Layer> &layers);

    static std::vector<Layer *> get_dominant_splitlayers(std::list<Layer> &layers, std::set<std::pair<Product *, Product *>> &collisions);

    static std::vector<Layer *> recombine_splitlayers(std::vector<Layer *> &layers);

    bool corresponding_matching_superface(const cFace *a);

    bool unifying_criteria(const cFace *a);

    bool unifying_criteria_openings(const cFace *a);

    bool check_face_normal(gp_Dir n, gp_Dir m, double AngularTolerance, const std::string &s) const;
};

#endif //CFACE_H
